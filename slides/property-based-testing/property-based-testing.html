<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="author" content="Erlang Solutions Ltd."><title>Property-Based Testing</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="reveal.js/css/reveal.min.css" rel="stylesheet"><link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme"><link href="reveal.js/lib/css/zenburn.css" rel="stylesheet"><script type="text/javascript">document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );</script></head><body><div class="reveal"><div class="slides"><section><h1>Property-Based Testing</h1><p>Erlang Solutions Ltd.</p></section><div id="preamble"><div class="sectionbody"><link rel="stylesheet" type="text/css" href="../../styles/svg.css"></link>
<script type="text/javascript" src="../../tools/snap.svg/snap.svg-min.js"></script></div></div>
<section id="_property_based_testing"><h2>Property-Based Testing</h2><div class="ulist"><ul><li><p>Principles</p></li><li><p>Using QuickCheck</p></li><li><p>Unit Tests Vs. Property-based Tests</p></li><li><p>Shrinking Strategies</p></li><li><p>Gathering Statistics</p></li><li><p>Other Tools</p></li></ul></div></section>
<section id="_principles"><h2>Principles</h2><div class="left">
<div class="pre">sort([]) -> [];
sort([H|T]) ->
  sort([X || X <- T, X < H])
  ++ [H] ++
  sort([X || X <- T, X > H]).

tests() ->
  [1,2,3] = sort([1,3,2]),
  true = sort([3,7,2]) =:=
         sort(sort([3,7,2])).

%% fails with [1,1], but tests
%% will <b>pass</b>!


</div></div>
<div class="ulist right"><ul><li><p>Writing good unit tests is difficult</p></li><li><p>Programmer assumptions can leave scenarios untested, even with 100% coverage</p></li><li><p>Corner cases are often forgotten or sometimes hard to predict</p></li></ul></div></section>
<section id="_principles_2"><h2>Principles</h2><div class="ulist"><ul><li><p>Define properties and invariants that a tested function should satisfy in every use case</p></li><li><p>Let the test framework generate test data to run against all properties and invariants</p></li><li><p>Tests can be ran with thousands of different inputs, generated automatically</p></li><li><p>Helps uncovering corner cases and faulty specifications by dynamically generating more tests than what could be written by hand</p></li></ul></div></section>
<section id="_using_quickcheck"><h2>Using QuickCheck</h2><div class="ulist"><ul><li><p>QuickCheck is a property-based test framework developed by QuviQ</p></li><li><p>Uses <strong>properties</strong>, which are general tests or invariants that should be respected</p></li><li><p>Lets you define <strong>generators</strong>, giving you control of the distribution of the input generated for properties</p></li><li><p>Failing cases can be reduced to simple expressions that highlight why properties or invariants were broken. This is called <strong>shrinking</strong>.</p></li></ul></div></section>
<section id="_using_quickcheck_strong_structure_strong"><h2>Using QuickCheck: <strong>structure</strong></h2><div style="text-align:center; margin-top:100px;">
<svg id="using_quickcheck_structure_1" style="width:590px; height:410px;" viewBox="0 0 590 410" preserveAspectRatio="xMinYMin meet">
<script>

var s1 = Snap("#using_quickcheck_structure_1");

var arrow = s1.polygon([-2,0, -4,4, 4,0, -4,-4]).transform('r0 s1.125');
var marker = arrow.marker(-6, -6, 12, 12).attr({"markerWidth":"6"});

s1.rect(10,10,260,60,12).addClass("shape line").attr({"stroke-width":"2px"});
s1.text(140,50,"Quickcheck").addClass("middle");

s1_g1 = s1.g(s1.path("M245,70 l0,73").addClass("line").attr({"marker-end":marker}),
             s1.text(275,120,"Runs properties").addClass("darkred")).addClass("hide");

s1_g2 = s1.g(s1.rect(10,150,260,60,12).addClass("shape line").attr({"stroke-width":"2px"}),
             s1.text(140,190,"Properties").addClass("middle")).addClass("hide");

s1_g3 = s1.g(s1.path("M245,210 l0,73").addClass("line").attr({"marker-end":marker}),
             s1.text(275,260,"Use generators' data").addClass("darkred")).addClass("hide");

s1_g4 = s1.g(s1.rect(10,290,260,60,12).addClass("shape line").attr({"stroke-width":"2px"}),
             s1.text(140,330,"Generators").addClass("middle")).addClass("hide");

s1_g5 = s1.g(s1.path("M270,310 C370,350 250,450 220,357").addClass("line").attr({"marker-end":marker}),
             s1.text(450,360,"Can be built with").addClass("darkred middle"),
             s1.text(450,395,"other generators").addClass("darkred middle")).addClass("hide");

s1_anim1 = function() { s1_g1.animate({"opacity":"1"}, 375, mina.linear, s1_anim2); }
s1_anim2 = function() { s1_g2.animate({"opacity":"1"}, 375, mina.linear); }
s1_anim3 = function() { s1_g3.animate({"opacity":"1"}, 375, mina.linear, s1_anim4); }
s1_anim4 = function() { s1_g4.animate({"opacity":"1"}, 375, mina.linear, s1_anim5); }
s1_anim5 = function() { s1_g5.animate({"opacity":"1"}, 375, mina.linear); }

var s1_counter=1
s1.click( function() {
  switch(s1_counter) {
    case 1: {s1_anim1(); s1_counter++; break};
    case 2: {s1_anim3(); s1_counter++; break};
    }
} );

</script>
</svg></section>
<section id="_using_quickcheck_2"><h2>Using QuickCheck</h2><div class="ulist"><ul><li><p>Test modules must include the <strong>eqc.hrl</strong> header.</p></li><li><p>3 modules are available:</p><div class="ulist"><ul><li><p><strong>eqc</strong> provides functions to write properties and tests.</p></li><li><p><strong>eqc_gen</strong> contains functions to write generators, used to create randomised input to test functions</p></li><li><p><strong>eqc_symbolic</strong> lets create generators, but also lets quickcheck understand how the generator is built to better shrink results.</p></li></ul></div></li><li><p>Much of the interface to the modules is accessible through macros in <strong>eqc.hrl</strong>. Functions from the 3 modules are all automatically imported.</p></li></ul></div></section>
<section id="_using_quickcheck_strong_running_tests_strong"><h2>Using QuickCheck: <strong>running tests</strong></h2><svg id="using_quickcheck_running_tests_1" style="width:1100px; height:600px;" viewBox="0 0 1100 600" preserveAspectRatio="xMinYMin meet">
<script>

var s2 = Snap("#using_quickcheck_running_tests_1");

var arrow = s2.polygon([-2,0, -4,4, 4,0, -4,-4]).transform('r0 s1.125').addClass("darkred");
var marker = arrow.marker(-6, -6, 12, 12).attr({"markerWidth":"6"});

s2.text(10,40,"1> eqc:module(demo).").addClass("code darkred bold");
s2.text(10,80,"prop_one: ").addClass("code");
s2.text(10,120,"........................................................").addClass("code");
s2.text(10,160,"OK, passed 100 tests").addClass("code");
s2.text(10,200,"prop_two: ").addClass("code");
s2.text(10,240,"........................................................").addClass("code");
s2.text(10,280,"OK, passed 100 tests").addClass("code");

s2_g1 = s2.g(s2.text(735,68,"finds all functions of the module").addClass("darkred middle"),
             s2.text(735,103,"beginning in prop_*").addClass("darkred middle"),
             s2.path("M580,95 l-345,-38").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");

s2_g2 = s2.g(s2.text(735,350,"Runs randomised versions of the").addClass("darkred middle"),
             s2.text(735,385,"test 100 times").addClass("darkred middle"),
             s2.path("M535,320 l-290,-145").addClass("line_darkred").attr({"marker-end":marker}),
             s2.path("M535,320 l-280,-30").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");

var s2_counter=1
s2.click( function() {
  switch(s2_counter) {
    case 1: {s2_g1.animate({"opacity":"1"}, 375, mina.linear); s2_counter++; break};
    case 2: {s2_g1.animate({"opacity":"0"}, 250, mina.linear); s2_g2.animate({"opacity":"1"}, 375, mina.linear); s2_counter++; break};
    }
} );

</script>
</svg></section>
<section id="_using_quickcheck_strong_running_tests_strong_2"><h2>Using QuickCheck: <strong>running tests</strong></h2><svg id="using_quickcheck_running_tests_2" style="width:1100px; height:600px;" viewBox="0 0 1100 600" preserveAspectRatio="xMinYMin meet">
<script>

var s3 = Snap("#using_quickcheck_running_tests_2");

var arrow = s3.polygon([-2,0, -4,4, 4,0, -4,-4]).transform('r0 s1.125').addClass("darkred");
var marker = arrow.marker(-6, -6, 12, 12).attr({"markerWidth":"6"});

s3.text(10,40,"1> eqc:module(demo).").addClass("code darkred bold");
s3.text(10,80,"prop_one: ").addClass("code");
s3.text(10,120,"........................................................").addClass("code");
s3.text(10,160,"OK, passed 100 tests").addClass("code");
s3.text(10,200,"prop_two: ").addClass("code");
s3.text(10,240,"........................................................").addClass("code");
s3.text(10,280,"OK, passed 100 tests").addClass("code");
s3.text(10,320,"2> eqc:module(demo).").addClass("code darkred bold");
s3.text(10,360,"prop_one: ").addClass("code");
s3.text(10,400,"........................................................").addClass("code");
s3.text(10,440,"OK, passed 100 tests").addClass("code");
s3.text(10,480,"prop_two:").addClass("code");
s3.text(10,520,".................................Failed! After 96 tests.").addClass("code");
s3.text(10,560,"418").addClass("code");

s3_g1 = s3.g(s3.text(735,68,"Randomised inputs means the").addClass("darkred middle"),
             s3.text(735,106,"tests do not always give the").addClass("darkred middle"),
             s3.text(735,144,"same results").addClass("darkred middle"),
             s3.path("M795,154 l40,330").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");

s3_g2 = s3.g(s3.text(570,330,"The faulty input is shown").addClass("darkred middle"),
             s3.text(570,368,"after the failing case").addClass("darkred middle"),
             s3.path("M570,378 l-485,170").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");

var s3_counter=1
s3.click( function() {
  switch(s3_counter) {
    case 1: {s3_g1.animate({"opacity":"1"}, 375, mina.linear); s3_counter++; break};
    case 2: {s3_g1.animate({"opacity":"0"}, 375, mina.linear); s3_g2.animate({"opacity":"1"}, 375, mina.linear); s3_counter++; break};
    }
} );

</script>
</svg></section>
<section id="_using_quickcheck_strong_running_tests_strong_3"><h2>Using QuickCheck: <strong>running tests</strong></h2><div class="left w_600">
<div class="pre"><b>3> eqc:quickcheck(demo:prop_two()).</b>
...................................
.....
OK, passed 100 tests
true

<b>4> eqc:quickcheck(eqc:numtests(300, demo:prop_two())).</b>
...................................
...................................
...Failed! After 162 tests.
418
false

</div></div>
<div class="ulist right"><ul><li><p>The function <strong>eqc:quickcheck/1</strong> allows to run each property individually</p></li><li><p>Using <strong>eqc:numtests/2</strong> on a property allows to set the number of tests to be run, if necessary</p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>At this point, have the students compile Accounts/quickcheck/demo.erl and try to run these functions and the examples before</p></div></aside></section>
<section id="_using_quickcheck_strong_properties_strong"><h2>Using QuickCheck: <strong>properties</strong></h2><div class="left w_600">
<div class="pre">prop_reverse() ->
  <b>?FORALL(</b>Xs<b>,</b> list(int()),
    lists:reverse(
      lists:reverse(Xs)) == Xs<b>)</b>.

prop_fib() ->
  ?FORALL(I, nat(),
   <b>?IMPLIES(</b>I > 2<b>,</b>
    fib(I) =:=
    fib(I-1) + fib(I-2)<b>)</b>).

prop_fail() ->
  ?FORALL(I, nat(),
   <b>?WHENFAIL(</b>io:format("Woops")<b>,</b>
     I < 3<b>)</b>).

</div></div>
<div class="ulist right"><ul><li><p>The <strong>?FORALL(Var, Generator, Prop)</strong> macro tests that <strong>Prop</strong> is true for all values extracted from <strong>Generator</strong>.</p></li><li><p>The <strong>?IMPLIES(Pre, Prop)</strong> macro only tests <strong>Prop</strong> when the precondition <strong>Pre</strong> is successful.</p></li><li><p><strong>?WHENFAIL(Action, Prop)</strong> will execute <strong>Action</strong> whenever <strong>Prop</strong> fails.</p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Might want to describe the <em>fails/1</em> function for tests that should fail at some point
Get the students to do the related exercise on writing properties.</p></div></aside></section>
<section id="_using_quickcheck_strong_generators_strong"><h2>Using QuickCheck: <strong>generators</strong></h2><div class="literalblock"><div class="content"><pre>1&gt; eqc_gen:sample(eqc_gen:int()).
7 -9 3 1 3 15 -15 -4 16 6 5
ok
2&gt; eqc_gen:sample(eqc_gen:choose(1,100)).
88 35 52 35 41 97 4 9 26 54 59
ok
 </pre></div></div>
<div class="ulist"><ul><li><p>Generators denote a set of values that can be created</p></li><li><p>Generators can control the probability distribution of values that will be created</p></li><li><p>They contain a mechanism to shrink values if a test fails</p></li><li><p>The function <strong>eqc_gen:sample/1</strong> returns 11 random values from a generator.</p></li></ul></div></section>
<section id="_using_quickcheck_strong_generators_strong_2"><h2>Using QuickCheck: <strong>generators</strong></h2><div class="dlist"><dl><dt class="hdlist1"><strong>binary(), binary(Size)</strong></dt><dd><p>Returns binaries of random or <strong>Size</strong> size (in bytes). the functions <strong>bitstring()</strong> and <strong>bitstring(Size)</strong> do the same, but in bits.</p></dd><dt class="hdlist1"><strong>bool()</strong></dt><dd><p>Creates a random boolean</p></dd><dt class="hdlist1"><strong>char()</strong></dt><dd><p>Creates a random character</p></dd><dt class="hdlist1"><strong>choose(Min,Max)</strong></dt><dd><p>Selects integer values in the range of <strong>Min</strong> to <strong>Max</strong>.</p></dd></dl></div></section>
<section id="_using_quickcheck_strong_generators_strong_3"><h2>Using QuickCheck: <strong>generators</strong></h2><div class="dlist"><dl><dt class="hdlist1"><strong>default(X, Generator)</strong></dt><dd><p>Adds a default value to a generator. It should be chosen about half the time.</p></dd><dt class="hdlist1"><strong>elements(List)</strong></dt><dd><p>Chooses values from List.</p></dd><dt class="hdlist1"><strong>int()</strong></dt><dd><p>Generates small integers. The generator <strong>largeint/0</strong> should be used for larger integers.</p></dd><dt class="hdlist1"><strong>list(Generator)</strong></dt><dd><p>Generates lists of elements returned by <strong>Generator</strong>.</p></dd></dl></div></section>
<section id="_using_quickcheck_strong_generators_strong_4"><h2>Using QuickCheck: <strong>generators</strong></h2><div class="dlist"><dl><dt class="hdlist1"><strong>nat()</strong></dt><dd><p>Generates small natural numbers</p></dd><dt class="hdlist1"><strong>real()</strong></dt><dd><p>Generates real numbers</p></dd><dt class="hdlist1"><strong>shuffle(List)</strong></dt><dd><p>Returns a shuffled version of the <strong>List</strong> list.</p></dd><dt class="hdlist1"><strong>vector(Length, Generator)</strong></dt><dd><p>Generates vectors of length <strong>Length</strong> with values obtained from <strong>Generator</strong> to fill it.</p></dd></dl></div></section>
<section id="_using_quickcheck_strong_generators_strong_5"><h2>Using QuickCheck: <strong>generators</strong></h2><div class="dlist"><dl><dt class="hdlist1"><strong>resize(N, Generator)</strong></dt><dd><p>If Generator calls other generators like <strong>int/0</strong> and <strong>nat/0</strong>, and changes the range of results obtained to tend towards <strong>N</strong>.</p></dd><dt class="hdlist1"><strong>frequency([{Weight, Generator}])</strong></dt><dd><p>Selects an element from a generator chosen randomly with probability proportional to its weight. Weights should be non-negative integers.</p></dd><dt class="hdlist1"><strong>oneof([Generator])</strong></dt><dd><p>Generates a value using a randomly chosen generator from the list.</p></dd></dl></div>
<aside class="notes"><div class="paragraph"><p>After this slide, let the students take on the generators exercise</p></div></aside></section>
<section id="_using_quickcheck_strong_generator_macros_strong"><h2>Using QuickCheck: <strong>generator macros</strong></h2><div class="left">
<div class="pre">zip() ->
  <b>?LET(</b>{L1,L2},
       {vector(10,nat()),
        vector(10,binary())},
        lists:zip(L1,L2<b>)</b>).

even() ->
  <b>?SUCHTHAT(</b>L, list(nat()),
    each_even(L<b>)</b>).

<b>recurse()</b> ->
  <b>?LAZY(</b>oneof(
    [[], [int()|<b>recurse()</b>]]
  )<b>)</b>.
</div></div>
<div class="ulist right"><ul><li><p><strong>?LET(Pat, G1, G2)</strong> will take values created by <strong>G1</strong>, will assign them in <strong>Pat</strong> and use them with <strong>G2</strong> to create a new generator.</p></li><li><p><strong>?SUCHTHAT(X, G, Pre)</strong> will take values from <strong>G</strong>, assign them to <strong>X</strong> and only return them if the precondition <strong>Pre</strong> is true.</p></li><li><p><strong>?LAZY(Gen)</strong> allows to evaluate <strong>Gen</strong> in constant time and get termination.</p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Do the exercise on Generator Macros, followed by the exercise on protocol testing</p></div></aside></section>
<section id="_quickcheck_strong_tests_as_specifications_strong"><h2>QuickCheck: <strong>tests as specifications</strong></h2><div class="left w_600">
<div class="pre">prop_alphanumeric() ->
  ?FORALL(S, string(),
    ?IMPLIES(S =/= "",
     is_alphanumeric(slug(S)))).


prop_no_dash_sequence() ->
  ?FORALL(S, string(),
   ?IMPLIES(S =/= "",
    begin
      Slug = slug(S),
      has_no_dash_sequence(Slug)
    end)).

</div></div>
<div class="ulist right"><ul><li><p>Design a piece of code that allows its users to 'sluggify' a string</p></li><li><p>A slug should contain only alphanumeric characters and hyphens (<strong>—</strong>)</p></li><li><p>A slug should not contain consecutive hyphens</p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Mention that TDD properties can be translated into QuickCheck properties to be used in a TDD concept. The exercise on TDD with quickcheck can be given.</p></div></aside></section>
<section id="_unit_tests_vs_property_based_tests"><h2>Unit Tests vs. Property-based Tests</h2><div class="dlist left comparison darkred"><dl><dt class="hdlist1">Unit Tests</dt><dd><div class="ulist"><ul><li><p>Unit Tests require the programmer to think of all corner cases and explicitly formulate them</p></li><li><p>Tests are static and repeatable</p></li><li><p>Tests are usually more verbose because you need more to cover all of the code. Makes it hard to write tests first.</p></li></ul></div></dd></dl></div>
<div class="dlist right comparison darkred"><dl><dt class="hdlist1">Property-based Tests</dt><dd><div class="ulist"><ul><li><p>Property-based tests might eventually hit corner cases the programmer hadn&#8217;t planned for</p></li><li><p>There is no guarantee that  a specific input will be provided all the time</p></li><li><p>Badly written generators might cause tests to run for a long time before generating interesting data</p></li></ul></div></dd></dl></div></section>
<section id="_unit_tests_vs_property_based_tests_2"><h2>Unit Tests vs. Property-based Tests</h2><div class="left">
<div class="pre">swap([A,B|Rest]) ->
    [B,A|swap(Rest)];
swap(L) when is_list(L) -> L.

unit_test() ->
    "" = swap(""),
    "c" = swap("c"),
    "abab" = swap("baba"),
    "ababc" = swap("babac"),
    ok.

</div></div>
<div class="ulist right"><ul><li><p>Unit tests describe what <strong>swap/1</strong> does explicitly with example input and output</p></li><li><p>The function is simple; we assume the tests cover it well.</p></li></ul></div></section>
<section id="_unit_tests_vs_property_based_tests_3"><h2>Unit Tests vs. Property-based Tests</h2><div class="left">
<div class="pre">swap([A,B|Rest]) ->
    [B,A|swap(Rest)];
swap(L) when is_list(L) -> L.

prop_swap() ->
    numtests(1000,
     ?FORALL(L, list(char()),
      is_swapped(L,swap(L)))).

is_swapped([A,B|Xs],[B,A|Ys]) ->
    is_swapped(Xs,Ys);
is_swapped(L,L) when length(L) =< 1 ->
    true;
is_swapped(_,_) -> false.

</div></div>
<div class="ulist right"><ul><li><p>The implementation of <strong>is_swapped/2</strong> is similar to <strong>swap/1</strong>.</p></li><li><p>Both implementations could be wrong, no simple way to know it but to add more tests</p></li></ul></div></section>
<section id="_unit_tests_vs_property_based_tests_4"><h2>Unit Tests vs. Property-based Tests</h2><div class="ulist"><ul><li><p>Tests for many different inputs without too much code</p></li><li><p>It is probable that property-based tests will uncover more corner cases</p></li><li><p>Assumptions about the code had to be formalised rather than expressed through examples</p></li><li><p>Will give better code coverage</p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Do the exercises the slug properties</p></div></aside></section>
<section id="_shrinking_strategies_strong_symbolic_calls_strong"><h2>Shrinking Strategies: <strong>symbolic calls</strong></h2><div class="pre">prop_x() -> ?FORALL(D, <b>dict()</b>, some_failing_property(D)).

<b>dict()</b> ->
  ?LAZY(
    oneof([dict:new(),
           ?LET(D,dict(), dict:store(int(), int(), D))])).

</div>
<div class="ulist"><ul><li><p>Generates a random dictionary</p></li><li><p>When the property test fails, the resulting dictionary is output to the screen</p></li></ul></div></section>
<section id="_shrinking_strategies_strong_finding_an_error_strong"><h2>Shrinking Strategies: <strong>finding an error</strong></h2><svg id="shrinking_strategies_finding_an_error_1" style="width:1100px; height:600px;" viewBox="0 0 1100 600" preserveAspectRatio="xMinYMin meet">
<script>

var s4 = Snap("#shrinking_strategies_finding_an_error_1");

var arrow = s4.polygon([-2,0, -4,4, 4,0, -4,-4]).transform('r0 s1.125').addClass("darkred");
var marker = arrow.marker(-6, -6, 12, 12).attr({"markerWidth":"6"});

s4.text(10,40,"6> eqc:quickcheck(dict_test:prop_x()).").addClass("code");
s4.text(10,80,"..........................................................").addClass("code");
s4.text(10,120,"...............................Failed! Reason: ").addClass("code");
s4.text(10,160,"{dict,4,16,16,8,80,48,").addClass("code");
s4.text(10,200,"      {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},").addClass("code");
s4.text(10,240,"      {{[],[],[],[],[],[],[],[],[],[],[],").addClass("code");
s4.text(10,280,"        [[0|-8],[-8|0],[-5|9],[-4|-9]],").addClass("code");
s4.text(10,320,"        [],[],[],[]}}}").addClass("code");
s4.text(10,360,"After 67 tests.").addClass("code");
s4.text(10,400,"false").addClass("code");

s4.path("M620,405 l-110,-105").addClass("line_darkred").attr({"marker-end":marker});
s4.text(750,410,"Reading the data").addClass("darkred middle");
s4.text(750,445,"structure is not easy").addClass("darkred middle");

</script>
</svg></section>
<section id="_shrinking_strategies_strong_finding_an_error_strong_2"><h2>Shrinking Strategies: <strong>finding an error</strong></h2><div class="ulist"><ul><li><p>The data structure contains the information on why it failed</p></li><li><p>It doesn&#8217;t tell us how the failing condition was obtained</p></li><li><p>Some cases are difficult to track</p><div class="ulist"><ul><li><p>Being able to see what calls were made to build the dictionary could help</p></li><li><p>QuickCheck provides a way to list and shrink the calls that were made named <strong>symbolic calls</strong>.</p></li></ul></div></li></ul></div></section>
<section id="_shrinking_strategies_strong_symbolic_calls_strong_2"><h2>Shrinking Strategies: <strong>symbolic calls</strong></h2><div class="dlist"><dl><dt class="hdlist1"><strong>Symbolic call</strong></dt><dd><p>A call of the form <strong>{call, Module, Function, ArgList]}</strong>. The call is not evaluated until the <strong>eval/1</strong> function is called.</p></dd><dt class="hdlist1"><strong>eval(Call)</strong></dt><dd><p>Evaluates the symbolic call <strong>Call</strong>.</p></dd><dt class="hdlist1"><strong>eval(PropList, Call)</strong></dt><dd><p>Evaluates the symbolic call <strong>Call</strong> with the variable definitions in <strong>PropList</strong>. The call <strong>eval([{x,7}], {call, erlang, is_number,[{var,x}]})</strong> evaluates to <strong>true</strong>.</p></dd></dl></div></section>
<section id="_shrinking_strategies_strong_symbolic_calls_strong_3"><h2>Shrinking Strategies: <strong>symbolic calls</strong></h2><div class="pre">prop_x() ->
  ?FORALL(D, dict(), some_failing_property(<b>eval(</b>D<b>)</b>)).
dict() ->
  ?LAZY(
    oneof([<b>{call, dict, new, []}</b>,
           <b>{call, dict, store, [</b>int(), int(), dict()<b>]}</b>])).

</div>
<div class="ulist"><ul><li><p>By using a symbolic generator, <strong>?LET</strong> is no longer needed</p></li><li><p>A call <strong>eval(Gen)</strong> is required in order to use the symbolic generator in an actual test</p></li><li><p>The calls with <strong>{call, Mod, Fun, [Args]}</strong> are reduced to a single expression when the tests run, but can be expanded if it fails</p></li></ul></div></section>
<section id="_shrinking_strategies_strong_symbolic_calls_strong_4"><h2>Shrinking Strategies: <strong>symbolic calls</strong></h2><svg id="shrinking_strategies_symbolic_calls_1" style="width:1100px; height:600px;" viewBox="0 0 1100 600" preserveAspectRatio="xMinYMin meet">
<script>

var s5 = Snap("#shrinking_strategies_symbolic_calls_1");

var arrow = s5.polygon([-2,0, -4,4, 4,0, -4,-4]).transform('r0 s1.125').addClass("darkred");
var marker = arrow.marker(-6, -6, 12, 12).attr({"markerWidth":"6"});

s5.text(10,40,"1> eqc:quickcheck(dict_test:prop_x()).").addClass("code darkred bold");
s5.text(10,80,"...................Failed! After 20 tests.").addClass("code");
s5.text(10,120,"{call,dict,store,").addClass("code");
s5.text(10,160,"      [5,1,").addClass("code");
s5.text(10,200,"       {call,dict,store,[6,2,{call,dict,store,[6,-3,").addClass("code");
s5.text(10,240,"        {call,dict,new,[]}]}]}]}").addClass("code");
s5.text(10,280,"Shrinking.......(7 times)").addClass("code");

s5.text(10,360,"{call,dict,store,").addClass("code");
s5.text(10,400,"      [1,0,").addClass("code");
s5.text(10,440,"       {call,dict,store,[1,0,{call,dict,store,[6,0,").addClass("code");
s5.text(10,480,"        {call,dict,new,[]}]}]}]}").addClass("code");
s5.text(10,520,"false").addClass("code");

s5_g1 = s5.g(s5.text(800,320,"Likely the problem value!").addClass("darkred middle"),
             s5.path("M800,330 l35,75").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");

s5.click( function() {s5_g1.animate({"opacity":"1"}, 375, mina.linear)});

</script>
</svg>
<aside class="notes"><div class="paragraph"><p>Emphasise the call stack being shrunken by QuickCheck. Easy to go through the calls manually to inspect random cases.
Mention that symbolic calls are a good way to use side-effecting functions in generators</p></div>
<div class="paragraph"><p>Exercise on symbolic representation here</p></div></aside></section>
<section id="_symbolic_calls_strong_example_strong"><h2>Symbolic Calls: <strong>example</strong></h2><svg id="symbolic_calls_example_1" style="width:600px; height:650px;" viewBox="0 0 600 650" preserveAspectRatio="xMinYMin meet" class="left">
<script>

var s6 = Snap("#symbolic_calls_example_1");

var arrow = s6.polygon([-2,0, -4,4, 4,0, -4,-4]).transform('r0 s1.125').addClass("darkred");
var marker = arrow.marker(-6, -6, 12, 12).attr({"markerWidth":"6"});

s6.rect(10,5,600,635).addClass("rect_code");

s6.text(20,40,"-module(zipper_lists).").addClass("code");
s6.text(20,79,"...").addClass("code");
s6.text(20,118,"new() -> {[], []}.").addClass("code");
s6.text(20,157,"insert(V,{L,R})-> {L,[V|R]}.").addClass("code");

s6.text(20,235,"prev({[], _Post}) -> undefined;").addClass("code");
s6.text(20,274,"prev({[H|T], Post}) ->").addClass("code");
s6.text(20,313,"    {T,[H|Post]}.").addClass("code");
s6.text(20,352,"").addClass("code");
s6.text(20,391,"next({_Pre, []}) -> undefined;").addClass("code");
s6.text(20,430,"next({Pre, [H|T]}) ->").addClass("code");
s6.text(20,469,"    {[H|Pre], T}.").addClass("code");
s6.text(20,508,"").addClass("code");
s6.text(20,547,"current({_, []}) -> undefined;").addClass("code");
s6.text(20,586,"current({_, [Current|_]}) ->").addClass("code");
s6.text(20,625,"    {ok,Current}.").addClass("code");

s6_g1_1 = s6.g(s6.circle(150.5,263,15).addClass("line_darkred").attr({"stroke-width":"2.5px"}),
             s6.path("M145,277 C126,350 150,350 165,324").addClass("line_darkred").attr({"marker-end":marker}));

s6_g1_2 = s6.g(s6.circle(238.25,419,15).addClass("line_darkred").attr({"stroke-width":"2.5px"}),
             s6.path("M243,433 C275,510 160,510 140,480").addClass("line_darkred").attr({"marker-end":marker}));

s6_g1 = s6.g(s6_g1_1, s6_g1_2).addClass("hide");

s6.click( function() {s6_g1.animate({"opacity":"1"}, 375, mina.linear)});

</script>
</svg>
<div class="ulist right w_400"><ul><li><p>A zipper list is a list that can be navigated from left to right and from right to left</p></li><li><p>The history of seen element is moved from one of the two lists to the other</p><div class="ulist"><ul><li><p>This allows a simple way to browse back and forth within the structure</p></li></ul></div></li></ul></div></section>
<section id="_symbolic_calls_strong_example_strong_2"><h2>Symbolic Calls: <strong>example</strong></h2><div class="pre">
<span class="comment">%% Generates random movement through the zipper</span>
move(Z) ->
  ?LAZY(frequency([
    {1, Z},
    {3, ?LET(Zip, move(Z), {call, ?MODULE, prev, [Zip]})},
    {3, ?LET(Zip, move(Z), {call, ?MODULE, next, [Zip]})}
  ])).

</div>
<div class="ulist"><ul><li><p>The generator accepts an existing zipper and will build a symbolic list of calls that represent someone browsing through the data structure</p></li></ul></div></section>
<section id="_symbolic_calls_strong_example_strong_3"><h2>Symbolic Calls: <strong>example</strong></h2><div class="pre"><span class="comment">%% Test going to the next point</span>
prop_next() ->
    Z = {[3,2,1], [4,5,6]},
    ?FORALL(Move, move(Z),
        is_tuple(current(eval(Move)))).

</div>
<div class="paragraph"><p>The property tests that the random movement is possible</p></div>
<div class="pre">2> eqc:module(zipper_lists).
prop_next: ........Failed! After 9 tests.
{call,zipper_lists,<b>next</b>,
   [{call,zipper_lists,<b>next</b>,
      [{call,zipper_lists,<b>next</b>,[{[3,2,1],<b>[4,5,6]</b>}]}]}]}
[prop_next]

</div></section>
<section id="_symbolic_calls_strong_example_strong_4"><h2>Symbolic Calls: <strong>example</strong></h2><svg id="symbolic_calls_example_2" style="width:1100px; height:650px;" viewBox="0 0 1100 650" preserveAspectRatio="xMinYMin meet">
<script>

var s7 = Snap("#symbolic_calls_example_2");

var arrow = s7.polygon([-2,0, -4,4, 4,0, -4,-4]).transform('r0 s1.125').addClass("darkred");
var marker = arrow.marker(-6, -6, 12, 12).attr({"markerWidth":"6"});

s7.text(40,40,"2> eqc:module(zipper_lists).").addClass("code");
s7.text(40,80,"prop_next: ........Failed! After 9 tests.").addClass("code");
s7.text(40,120,"{call,zipper_lists,next,").addClass("code");
s7_g4_g3 = s7.text(40,120,"                   next").addClass("code darkred bold");
s7.text(40,160,"   [{call,zipper_lists,next,").addClass("code");
s7_g3_g3 = s7.text(40,160,"                       next").addClass("code darkred bold");
s7.text(40,200,"      [{call,zipper_lists,next,[{[3,2,1],[4,5,6]}]}]}]}").addClass("code");
s7_g2_g3 = s7.text(40,200,"                          next").addClass("code darkred bold");
s7.text(40,240,"[prop_next]").addClass("code");

s7_g4_g4 = s7.text(447,107,"3").addClass("darkred bold").attr({"font-size":"17"});
s7_g3_g4 = s7.text(517,145,"2").addClass("darkred bold").attr({"font-size":"17"});
s7_g2_g4 = s7.text(564,180,"1").addClass("darkred bold").attr({"font-size":"17"});

s7_g1_g1 = s7.text(620,330,"{[3,2,1], [4,5,6]}").addClass("code");
s7_g2_g1 = s7.text(620,380,"{[4,3,2,1], [5,6]}").addClass("code");
s7_g3_g1 = s7.text(620,430,"{[5,4,3,2,1], [6]}").addClass("code");
s7_g4_g1 = s7.text(613,480,"{[6,5,4,3,2,1], []}").addClass("code");

s7_g2_g2 = s7.text(965,350,"1").addClass("darkred bold");
s7_g3_g2 = s7.text(965,400,"2").addClass("darkred bold");
s7_g4_g2 = s7.text(965,450,"3").addClass("darkred bold");

s7_g1_g2 = s7.text(260,320,"We can use the symbolic calls to").addClass("darkred middle");
s7_g1_g3 = s7.text(260,355,"find the reason why the test failed").addClass("darkred middle");

s7_g5 = s7.g(s7.text(60,540,"The call to current/1 fails").addClass("darkred"),
             s7.path("M435,532 850,532 Q900,530 908,498").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");

s7_g1 = s7.g(s7_g1_g1, s7_g1_g2, s7_g1_g3).addClass("hide");
s7_g2 = s7.g(s7_g2_g1, s7_g2_g2, s7_g2_g3, s7_g2_g4).addClass("hide");
s7_g3 = s7.g(s7_g3_g1, s7_g3_g2, s7_g3_g3, s7_g3_g4).addClass("hide");
s7_g4 = s7.g(s7_g4_g1, s7_g4_g2, s7_g4_g3, s7_g4_g4).addClass("hide");

var s7_counter=1
s7.click( function() {
  switch(s7_counter) {
    case 1: {s7_g1.animate({"opacity":"1"}, 375, mina.linear); s7_counter++; break};
    case 2: {s7_g2.animate({"opacity":"1"}, 375, mina.linear); s7_counter++; break};
    case 3: {s7_g3.animate({"opacity":"1"}, 375, mina.linear); s7_counter++; break};
    case 4: {s7_g4.animate({"opacity":"1"}, 375, mina.linear); s7_counter++; break};
    case 5: {s7_g5.animate({"opacity":"1"}, 375, mina.linear); s7_counter++; break};
    }
} );

</script>
</svg>
<aside class="notes"><div class="paragraph"><p>string:tokens/2 can take more than one character in its list, but we&#8217;ll focus on using only one for now</p></div></aside></section>
<section id="_shrinking_strategies"><h2>Shrinking Strategies</h2><div class="ulist"><ul><li><p>A test for the function <strong>string:tokens/2</strong></p></li><li><p>Assumes that a tokenised string will be split in one more parts than there are token, e.g. <strong>"axf da"</strong> with the token <strong>" "</strong> gives <strong>["axf", "da"]</strong>.</p></li><li><p>The character and the string are generated randomly</p></li><li><p>Using <strong>begin &#8230;&#8203; end</strong> allows to use many expressions as the proposition.</p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Remind students that without symbolic calls, it is hard to know why something failed</p></div></aside></section>
<section id="_shrinking_strategies_2"><h2>Shrinking Strategies</h2><svg id="shrinking_strategies_1" style="width:1100px; height:650px;" viewBox="0 0 1100 650" preserveAspectRatio="xMinYMin meet">
<script>

var s8 = Snap("#shrinking_strategies_1");

var arrow = s8.polygon([-2,0, -4,4, 4,0, -4,-4]).transform('r0 s1.125').addClass("darkred");
var marker = arrow.marker(-6, -6, 12, 12).attr({"markerWidth":"6"});

s8.text(10,40,"prop_split() ->").addClass("code");
s8.text(10,80,"  ?FORALL({C,S}, {char(),          (list(char()))},").addClass("code");
s8.text(10,80,"                          non_empty").addClass("code darkred bold");
s8.text(10,120,"      length(string:tokens(S,[C])) == count(C,S)).").addClass("code");

s8.text(10,200,"count(Char, [Char]) -> 0; ").addClass("code");
s8.text(10,240,"count(Char,String) -> count(Char,String, {Char,1}).").addClass("code");

s8.text(10,320,"count(_, [], {_,N}) -> N;").addClass("code");
s8.text(10,360,"count(C, [C], {_,N}) -> N;").addClass("code");
s8.text(10,400,"count(C, [C|T], Acc = {C,_}) -> count(C, T, Acc);").addClass("code");
s8.text(10,440,"count(C, [C|T], {_Prev,N}) -> count(C, T, {C,N+1});").addClass("code");
s8.text(10,480,"count(C, [H|T], {_,N}) -> count(C, T, {H,N}).").addClass("code");

s8_g1 = s8.g(s8.text(520,195,"String is token").addClass("darkred"),
             s8.path("M510,188 l-163,-2").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");
s8_g2 = s8.g(s8.text(490,300,"Last character is token").addClass("darkred"),
             s8.path("M480,292 l-250,53").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");
s8_g3 = s8.g(s8.text(610,355,"Two in a row").addClass("darkred"),
             s8.path("M600,345 l-383,45").addClass("line_darkred").attr({"marker-end":marker}),
             s8.path("M600,345 l-162,42").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");
s8_g4 = s8.g(s8.text(970,350,"Must count").addClass("darkred middle"),
             s8.text(970,385,"this one!").addClass("darkred middle"),
             s8.path("M885,365 l-57,52").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");
s8_g5 = s8.g(s8.text(280,530,"Regular character").addClass("darkred"),
             s8.path("M270,520 l-72,-30").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");

var s8_counter=1
s8.click( function() {
  switch(s8_counter) {
    case 1: {s8_g1.animate({"opacity":"1"}, 375, mina.linear); s8_counter++; break};
    case 2: {s8_g1.animate({"opacity":"0"}, 250, mina.linear); s8_g2.animate({"opacity":"1"}, 375, mina.linear); s8_counter++; break};
    case 3: {s8_g2.animate({"opacity":"0"}, 250, mina.linear); s8_g3.animate({"opacity":"1"}, 375, mina.linear); s8_counter++; break};
    case 4: {s8_g3.animate({"opacity":"0"}, 250, mina.linear); s8_g4.animate({"opacity":"1"}, 375, mina.linear); s8_counter++; break};
    case 5: {s8_g4.animate({"opacity":"0"}, 250, mina.linear); s8_g5.animate({"opacity":"1"}, 375, mina.linear); s8_counter++; break};
    }
} );

</script>
</svg>
<aside class="notes"><div class="paragraph"><p>Not 100% necessary to explain what this does. Can just mention that you have a solution to the proposition and that we want to know how reliable it is</p></div></aside></section>
<section id="_shrinking_strategies_3"><h2>Shrinking Strategies</h2><div class="literalblock"><div class="content"><pre>1&gt; eqc:module(str).
prop_split: ....................................................................................................
OK, passed 100 tests
 
 </pre></div></div>
<div class="ulist"><ul><li><p>The tests pass</p></li><li><p>No certainty as to what tests are passing</p></li><li><p>Finding out what they are can help generate more meaningful input for each test</p></li></ul></div></section>
<section id="_gathering_statistics"><h2>Gathering Statistics</h2><div class="literalblock"><div class="content"><pre>prop_split() -&gt;
  ?FORALL({C,S}, {char(), non_empty(list(char()))},
    collect({[C],S},
      length(string:tokens(S,[C])) == count(C,S))).
 
 
 </pre></div></div>
<div class="paragraph"><p>using <strong>collect/2</strong> allows to find what kind of results are obtained: </p></div>
<div class="literalblock"><div class="content"><pre>1% {[254],[141,186]}
1% {[252],[153,229]}
1% {[251],[166]}
...
1% {[249],[253,221,169,104]}
1% {[249],[32]}
 </pre></div></div></section>
<section id="_gathering_statistics_2"><h2>Gathering Statistics</h2><div class="pre">prop_split() ->
  ?FORALL({C,S}, {char(), non_empty(list(char()))},
    collect(<b>num_tokens</b>(C,S),
      length(string:tokens(S,[C])) == count(C,S))).

<b>num_tokens</b>(C,S) -> length([1 || X <- S, C == X]).

</div>
<div class="paragraph"><p><strong>num_tokens/2</strong> lets us know how many times a token appears: </p></div>
<div class="pre"><svg id="gathering_statistics_1" style="width:1000px; height:250px;" viewBox="0 0 1000 250" preserveAspectRatio="xMinYMin meet">
<script>

var s9 = Snap("#gathering_statistics_1");

var arrow = s9.polygon([-2,0, -4,4, 4,0, -4,-4]).transform('r0 s1.125').addClass("darkred");
var marker = arrow.marker(-6, -6, 12, 12).attr({"markerWidth":"6"});

s9.text(10,40,"1> eqc:quickcheck(str:prop_split()).").addClass("code");
s9.text(10,80,"..........................................................").addClass("code");
s9.text(10,120,"..........................................").addClass("code");
s9.text(10,160,"OK, passed 100 tests").addClass("code");
s9.text(10,200,"99% 0").addClass("code darkred bold");
s9.text(10,240,"1% 1").addClass("code darkred bold");

s9_g1 = s9.g(s9.text(510,210,"Almost always tests").addClass("darkred middle"),
             s9.text(510,245,"the same case!").addClass("darkred middle"),
             s9.path("M390,225 l-262,-32").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");

s9.click( function() {s9_g1.animate({"opacity":"1"}, 375, mina.linear)});

</script>
</svg></div></section>
<section id="_gathering_statistics_3"><h2>Gathering Statistics</h2><div class="literalblock"><div class="content"><pre>prop_split() -&gt;
  ?FORALL({C,S}, str_token(),
    collect(num_tokens(C,S),
      length(string:tokens(S,[C])) == count(C,S))).

str_token() -&gt; {$a,non_empty(list(choose($a, $m)))}.
 </pre></div></div>
<div class="paragraph"><p>Using generator <strong>str_token/0</strong> to make repetitions more probable:</p></div>
<div class="pre"><svg id="gathering_statistics_2" style="width:1000px; height:250px;" viewBox="0 0 1000 250" preserveAspectRatio="xMinYMin meet">
<script>

var s10 = Snap("#gathering_statistics_2");

s10.text(10,40,"1> eqc:quickcheck(eqc:numtests(1000,str:prop_split())).").addClass("code");
s10.text(10,80,"...........................").addClass("code");
s10.text(10,120,"Failed! After 27 tests.").addClass("code");
s10.text(10,160,"{97,\"bka\"}").addClass("code");
s10.text(10,200,"Shrinking..(2 times)").addClass("code");
s10.text(10,240,"{97,\"aa\"}").addClass("code");

s10_g1 = s10.g(s10.text(850,140,"New errors are ").addClass("darkred middle"),
               s10.text(850,180,"found!").addClass("darkred middle")).attr({"font-size":"26pt"}).addClass("hide");

s10.click( function() {s10_g1.animate({"opacity":"1"}, 375, mina.linear)});

</script>
</svg></div>
<aside class="notes"><div class="paragraph"><p>Explain the probabilities behind the new choice in generator to make things easier to follow</p></div></aside></section>
<section id="_gathering_statistics_4"><h2>Gathering Statistics</h2><svg id="gathering_statistics_3" style="width:1100px; height:650px;" viewBox="0 0 1100 650" preserveAspectRatio="xMinYMin meet">
<script>

var s11 = Snap("#gathering_statistics_3");

var arrow = s11.polygon([-2,0, -4,4, 4,0, -4,-4]).transform('r0 s1.125').addClass("darkred");
var marker = arrow.marker(-6, -6, 12, 12).attr({"markerWidth":"6"});

s11.text(10,40,"count(Char, String) ->").addClass("code");
s11.text(10,80,"    case drop_ends(Char, String) of").addClass("code");
s11.text(10,120,"      [] -> 0;").addClass("code");
s11.text(10,160,"      S  -> count(Char, S, {Char, 1})").addClass("code");
s11.text(10,200,"    end.").addClass("code");

s11.text(10,280,"drop_ends(C, S) ->").addClass("code");
s11.text(10,320,"    Same = fun(X) -> C == X end,").addClass("code");
s11.text(10,360,"    S2 = lists:dropwhile(Same, S),").addClass("code");
s11.text(10,400,"    lists:dropwhile(Same, lists:reverse(S2)).").addClass("code");

s11.text(10,480,"%% Same count as earlier").addClass("code");
s11.text(10,520,"count(_, [], {_,N}) -> ...").addClass("code");

s11_g1 = s11.g(s11.text(730,240,"Fixes the problem of many").addClass("darkred middle"),
               s11.text(730,275,"tokens at the beginning or").addClass("darkred middle"),
               s11.text(730,310,"end of string").addClass("darkred middle"),
               s11.path("M535,250 l-271,-158").addClass("line_darkred").attr({"marker-end":marker}),
               s11.path("M535,250 l-182,15").addClass("line_darkred").attr({"marker-end":marker})).addClass("hide");

s11.click( function() {s11_g1.animate({"opacity":"1"}, 375, mina.linear)});

</script>
</svg>
<aside class="notes"><div class="paragraph"><p>Don&#8217;t need to go into the details, just mention that this is a fix that solves the problem s the code had. Important things in next slide</p></div></aside></section>
<section id="_gathering_statistics_5"><h2>Gathering Statistics</h2><div class="literalblock left"><div class="content"><pre>82&gt; eqc:quickcheck(eqc:numtests(1000,str:prop_split())).
.......................................................................................
OK, passed 1000 tests
69% 0
22% 1
5% 2
1% 3
0% 5
0% 4
 </pre></div></div>
<div class="ulist right"><ul><li><p>The bugs are fixed</p></li><li><p>The distribution of tests is now saner</p></li><li><p>The distribution of the input&#8217;s randomness helps focus tests on finding new bugs or making the appearance of a bug more frequent</p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Distribution is not perfect, but much more reliable.
Suggest doing the advanced exercises?
IF the students want to see another real-world use case, you can guide them through the min-binary heap exercise and solution.</p></div></aside></section>
<section id="_other_tools"><h2>Other Tools</h2><div class="dlist"><dl><dt class="hdlist1"><strong>QuickCheck</strong></dt><dd><p>comes in a commercial version, or a free closed source version called QuickCheck Mini.</p></dd><dt class="hdlist1"><strong>Triq</strong></dt><dd><p>API modelled closely after QuickCheck, but the latter has many features not found in Triq (reporting, management, C integration, better shrinking). Under the Apache license.</p></dd><dt class="hdlist1"><strong>Proper</strong></dt><dd><p>Also QuickCheck-inspired. Distributed under GPL Version 3 or later.</p></dd></dl></div>
<aside class="notes"><div class="paragraph"><p>QuickCheck: <a href="http://quviq.com/" class="bare">http://quviq.com/</a>
Triq: <a href="https://github.com/krestenkrab/triq" class="bare">https://github.com/krestenkrab/triq</a>
Proper: <a href="https://github.com/manopapad/proper" class="bare">https://github.com/manopapad/proper</a></p></div></aside></section>
<section id="_property_based_testing_2"><h2>Property-Based Testing</h2><div class="ulist"><ul><li><p>Principles</p></li><li><p>Using QuickCheck</p></li><li><p>Unit Tests Vs. Property-based Tests</p></li><li><p>Shrinking Strategies</p></li><li><p>Gathering Statistics</p></li><li><p>Other Tools</p></li></ul></div></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.min.js"></script><script type="text/javascript">// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display controls in the bottom right corner
  controls: true,
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: true,
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: false,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  previewLinks: false,
  // Theme (e.g., beige, blond, default, moon, night, serif, simple, sky, solarized)
  theme: Reveal.getQueryHash().theme || 'esl',
  // Transition style (e.g., default, cube, page, concave, zoom, linear, fade, none)
  transition: Reveal.getQueryHash().transition || 'linear',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., default, none, slide, concave, convex, zoom)
  backgroundTransition: 'default',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
});</script></body></html>